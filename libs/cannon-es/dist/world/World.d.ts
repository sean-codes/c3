import { EventTarget } from '../utils/EventTarget';
import { Narrowphase } from '../world/Narrowphase';
import { Vec3 } from '../math/Vec3';
import { Material } from '../material/Material';
import { ContactMaterial } from '../material/ContactMaterial';
import { ArrayCollisionMatrix } from '../collision/ArrayCollisionMatrix';
import { OverlapKeeper } from '../collision/OverlapKeeper';
import { TupleDictionary } from '../utils/TupleDictionary';
import { RaycastResult } from '../collision/RaycastResult';
import { Body } from '../objects/Body';
import type { Broadphase } from '../collision/Broadphase';
import type { Solver } from '../solver/Solver';
import type { ContactEquation } from '../equations/ContactEquation';
import type { FrictionEquation } from '../equations/FrictionEquation';
import type { RayOptions, RaycastCallback } from '../collision/Ray';
import type { Constraint } from '../constraints/Constraint';
import type { Shape } from '../shapes/Shape';
export declare type WorldOptions = {
    gravity?: Vec3;
    allowSleep?: boolean;
    broadphase?: Broadphase;
    solver?: Solver;
    quatNormalizeFast?: boolean;
    quatNormalizeSkip?: number;
};
export declare class World extends EventTarget {
    dt: number;
    allowSleep: boolean;
    contacts: ContactEquation[];
    frictionEquations: FrictionEquation[];
    quatNormalizeSkip: number;
    quatNormalizeFast: boolean;
    time: number;
    stepnumber: number;
    default_dt: number;
    nextId: number;
    gravity: Vec3;
    broadphase: Broadphase;
    bodies: Body[];
    hasActiveBodies: boolean;
    solver: Solver;
    constraints: Constraint[];
    narrowphase: Narrowphase;
    collisionMatrix: ArrayCollisionMatrix;
    collisionMatrixPrevious: ArrayCollisionMatrix;
    bodyOverlapKeeper: OverlapKeeper;
    shapeOverlapKeeper: OverlapKeeper;
    materials: Material[];
    contactmaterials: ContactMaterial[];
    contactMaterialTable: TupleDictionary;
    defaultMaterial: Material;
    defaultContactMaterial: ContactMaterial;
    doProfiling: boolean;
    profile: {
        solve: number;
        makeContactConstraints: number;
        broadphase: number;
        integrate: number;
        narrowphase: number;
    };
    accumulator: number;
    subsystems: any[];
    addBodyEvent: {
        type: 'addBody';
        body: Body | null;
    };
    removeBodyEvent: {
        type: 'removeBody';
        body: Body | null;
    };
    idToBodyMap: {
        [id: number]: Body;
    };
    addBody: typeof World.prototype.add;
    removeBody: typeof World.prototype.remove;
    emitContactEvents: () => void;
    constructor(options?: WorldOptions);
    getContactMaterial(m1: Material, m2: Material): ContactMaterial;
    numObjects(): number;
    collisionMatrixTick(): void;
    addConstraint(c: Constraint): void;
    removeConstraint(c: Constraint): void;
    rayTest(from: Vec3, to: Vec3, result: RaycastResult | RaycastCallback): void;
    raycastAll(from?: Vec3, to?: Vec3, options?: RayOptions, callback?: RaycastCallback): boolean;
    raycastAny(from?: Vec3, to?: Vec3, options?: RayOptions, result?: RaycastResult): boolean;
    raycastClosest(from?: Vec3, to?: Vec3, options?: RayOptions, result?: RaycastResult): boolean;
    add(body: Body): void;
    remove(body: Body): void;
    getBodyById(id: number): Body;
    getShapeById(id: number): Shape | void;
    addMaterial(m: Material): void;
    addContactMaterial(cmat: ContactMaterial): void;
    step(dt: number, timeSinceLastCalled?: number, maxSubSteps?: number): void;
    internalStep(dt: number): void;
    clearForces(): void;
}
